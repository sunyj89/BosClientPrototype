

## B端组织架构管理前端开发方案 (React + Antd 版本)

### 1. 方案概述

**目标：** 开发一个基于React的B端系统组织架构管理页面。
**核心功能：**
1.  以树形结构清晰展示多层级、跨法人主体的复杂组织架构。
2.  点击树节点时，在右侧展示该组织单元的详细信息。
3.  在右侧同时展示该组织单元下的员工列表。
4.  UI界面需清晰区分不同类型的组织单元。

**最终效果：** 左侧为组织树，右侧为详情和人员列表的经典后台布局。

### 3. 核心功能模块设计

页面整体采用Ant Design的 `Layout` 组件，实现左`Sider`右`Content`的布局。

* **左侧Sider：** 宽度约为300px，放置组织树组件。
* **右侧Content：** 占据剩余空间，上下布局，上部为组织详情，下部为用户列表。

#### 3.1. 组件设计

1.  **`OrgTree.jsx` (组织树组件)**
    * **功能：** 负责展示整个集团的运营组织树。
    * **UI：** 使用 Ant Design 的 `Tree` 组件。
    * **特性：**
        * **自定义节点图标：** `treeData` 属性中为不同 `orgType` 的节点赋予不同的 `icon`。（例如: `<ApartmentOutlined />` 用于部门，`<BankOutlined />` 用于分公司等）。
        * **数据驱动：** 接收 `treeData`作为 props。
        * **事件：** 使用 `onSelect` 属性。当用户点击节点时，调用从父组件传入的 `handleSelect` 回调函数，并传递节点信息。

2.  **`OrgDetails.jsx` (组织详情组件)**
    * **功能：** 接收一个组织单元对象 (`selectedNode`) 作为 prop，展示其详细信息。
    * **UI：** 使用 `Card` 作为容器，`Descriptions` 用于展示键值对信息。
    * **展示字段：**
        * `名称`: `<Descriptions.Item label="名称">{node.name}</Descriptions.Item>`
        * `类型`: `<Descriptions.Item label="类型">{node.orgType}</Descriptions.Item>`
        * `上级`: `<Descriptions.Item label="上级">{node.parentName}</Descriptions.Item>`
        * **`法人主体`**: `<Descriptions.Item label="法人主体"><Tag color={...}>{node.legalEntity.name}</Tag></Descriptions.Item>` (使用 `Tag` 组件，并根据法人ID设置不同颜色)
        * `ID`: `<Descriptions.Item label="ID">{node.id}</Descriptions.Item>`

3.  **`UserList.jsx` (用户列表组件)**
    * **功能：** 接收一个用户数组 (`users`) 作为 prop，展示该单元下的所有用户信息。
    * **UI：** 使用 `Card` 和 `Table`。
    * **表格列 (`columns`):**
        * `title: '用户ID', dataIndex: 'id', key: 'id'`
        * `title: '姓名', dataIndex: 'name', key: 'name'`
        * `title: '岗位/角色', dataIndex: ['role', 'name'], key: 'role'`
        * `title: '操作', key: 'action', render: () => ...` (包含“编辑”、“删除”等按钮)
    * **特性：** `Card` 的 `title` 属性旁应有“添加用户”的 `Button`。

### 4. 数据结构和模拟数据 (Data Structure & Mock Data)

数据结构的核心思想不变，但我们用纯JS对象来描述。

#### 4.1. 数据结构描述

* **LegalEntity**: 一个对象，包含 `id` 和 `name`。
* **Role**: 一个对象，包含 `id` 和 `name`。
* **User**: 一个对象，包含 `id`, `name`, `orgUnitId` 和一个内嵌的 `role` 对象。
* **OrgUnit**: 一个对象，包含 `id`, `name`, `parentId`, `parentName`, `orgType`, 一个内嵌的 `legalEntity` 对象，以及一个可选的 `children` 数组用于树形结构。

#### 4.2. 完整的模拟数据 (JavaScript 格式)

这份JS代码与之前的版本完全相同，因为它是纯JavaScript，可以直接在React项目中使用。请将其保存为 `src/data/mockData.js`。

```javascript
// src/data/mockData.js

// --- 基础数据 ---
export const legalEntities = [
  { id: 1, name: "A公司 (总公司)" },
  { id: 2, name: "G公司" },
];

export const roles = [
  { id: 1, name: "集团CEO" },
  { id: 2, name: "部门总监" },
  { id: 3, name: "分公司总经理" },
  { id: 4, name: "服务区经理" },
  { id: 5, name: "站长" },
  { id: 6, name: "普通员工" },
];

// --- 数据生成逻辑 ---
// (这部分与之前的方案完全相同，此处省略以保持简洁，请直接复制之前的生成逻辑代码)
// ...
// let orgIdCounter = 1;
// ...
// export const orgTreeData = [root];
// export const userData = allUsers;
// --- 为方便使用，请将上一版方案中的完整 JS 代码粘贴到这里 ---
```
**请注意：** 为节省篇幅，请将上一方案中“完整的模拟数据”部分的JavaScript代码块完整地复制到您的 `mockData.js` 文件中。

### 5. API接口模拟 (API Endpoint Simulation)

在React中，我们可以在一个单独的文件中（如 `src/api/index.js`）模拟这些API调用。

```javascript
// src/api/index.js
import { orgTreeData, userData } from '../data/mockData'; // 假设mockData已填充完整

// 辅助函数：在树中递归查找节点
function findNodeInTree(nodes, id) {
  for (const node of nodes) {
    if (node.id === id) return node;
    if (node.children) {
      const found = findNodeInTree(node.children, id);
      if (found) return found;
    }
  }
  return null;
}

export const getOrgTree = () => {
  return new Promise(resolve => {
    setTimeout(() => resolve(orgTreeData), 200); // 模拟网络延迟
  });
};

export const getOrgDetailsById = (id) => {
  return new Promise(resolve => {
    const node = findNodeInTree(orgTreeData, id);
    setTimeout(() => resolve(node), 100);
  });
};

export const getUsersByOrgId = (orgId) => {
  return new Promise(resolve => {
    const users = userData.filter(user => user.orgUnitId === orgId);
    setTimeout(() => resolve(users), 150);
  });
};
```

### 6. 实施步骤建议 (React Hooks)

建议AI按以下步骤生成代码：
1.  **项目初始化：** `npx create-react-app my-org-app`，然后 `npm install antd`。
2.  **全局配置：** 在 `src/index.js` 或 `src/App.js` 中引入Ant Design的全局样式：`import 'antd/dist/reset.css';`。
3.  **创建数据和API层：**
    * 创建 `src/data/mockData.js` 并粘贴数据。
    * 创建 `src/api/index.js` 并粘贴API模拟函数。
4.  **组件开发：**
    * 创建 `src/components/OrgTree.jsx`。
    * 创建 `src/components/OrgDetails.jsx`。
    * 创建 `src/components/UserList.jsx`。
5.  **页面整合 (`src/App.js`):**
    * **状态管理:** 使用 `useState` Hook来管理整个页面的状态。
        ```jsx
        import React, { useState, useEffect } from 'react';
        // ...
        const [treeData, setTreeData] = useState([]);
        const [selectedNode, setSelectedNode] = useState(null);
        const [users, setUsers] = useState([]);
        const [loading, setLoading] = useState(false);
        ```
    * **数据获取:** 使用 `useEffect` Hook在组件首次加载时获取组织树数据。
        ```jsx
        useEffect(() => {
          getOrgTree().then(data => setTreeData(data));
        }, []);
        ```
    * **事件处理:** 创建一个回调函数 `handleNodeSelect`，用于处理树节点的点击事件。
        ```jsx
        const handleNodeSelect = (selectedKeys, { node }) => {
          if (selectedKeys.length > 0) {
            setLoading(true);
            setSelectedNode(node); // 更新详情
            getUsersByOrgId(node.id).then(userList => {
              setUsers(userList); // 更新用户列表
              setLoading(false);
            });
          }
        };
        ```
    * **组件渲染:** 在 `return` 语句中，使用Ant Design的 `Layout` 组件搭建页面框架，并将状态和回调函数作为 `props` 传递给子组件。
        ```jsx
        // 在 App.js 的 return 中
        <Layout>
          <Layout.Sider>
            <OrgTree treeData={treeData} onSelect={handleNodeSelect} />
          </Layout.Sider>
          <Layout.Content style={{ padding: '24px' }}>
            {selectedNode && <OrgDetails node={selectedNode} />}
            {selectedNode && <UserList users={users} loading={loading} />}
          </Layout.Content>
        </Layout>
        ```
---

// mockData.js

// --- 基础数据 ---
export const legalEntities = [
  { id: 1, name: "A公司 (总公司)" },
  { id: 2, name: "G公司" },
];

export const roles = [
  { id: 1, name: "集团CEO" },
  { id: 2, name: "部门总监" },
  { id: 3, name: "分公司总经理" },
  { id: 4, name: "服务区经理" },
  { id: 5, name: "站长" },
  { id: 6, name: "普通员工" },
];

// --- 数据生成逻辑 ---
let orgIdCounter = 1;
let userIdCounter = 1;

const aCompany = legalEntities.find(e => e.id === 1);
const gCompany = legalEntities.find(e => e.id === 2);

const allUsers = [];

// 辅助函数，创建用户
function createUser(name, orgUnitId, role) {
  const user = { id: userIdCounter++, name, orgUnitId, role };
  allUsers.push(user);
  return user;
}

// --- 生成组织架构数据 ---
const root = {
  id: orgIdCounter++,
  name: "集团总部",
  parentId: null,
  orgType: "HEADQUARTER",
  legalEntity: aCompany,
  children: [],
};
createUser("张三 (CEO)", root.id, roles.find(r => r.id === 1));

const departments = [
  { id: orgIdCounter++, name: "财务部" },
  { id: orgIdCounter++, name: "市场部" },
  { id: orgIdCounter++, name: "采购部" },
  { id: orgIdCounter++, name: "安全部" },
  { id: orgIdCounter++, name: "工程部" },
];

departments.forEach(dept => {
  root.children.push({
    ...dept,
    parentId: root.id,
    parentName: root.name,
    orgType: "DEPARTMENT",
    legalEntity: aCompany,
    children: [],
  });
  createUser(`总监-${dept.name.charAt(0)}`, dept.id, roles.find(r => r.id === 2));
});

const branches = [];
for (let i = 1; i <= 7; i++) {
  const branchId = orgIdCounter++;
  const branch = {
    id: branchId,
    name: `第${i}分公司`,
    parentId: root.id,
    parentName: root.name,
    orgType: "CITY_BRANCH",
    legalEntity: aCompany,
    children: [],
  };
  branches.push(branch);
  root.children.push(branch);
  createUser(`总经理-${i}`, branch.id, roles.find(r => r.id === 3));
}

// 为A公司和G公司创建服务区和加油站
function createServiceAreasAndStations(parentBranch, areaCount, stationPerArea, legalEntity) {
  for (let i = 1; i <= areaCount; i++) {
    const areaId = orgIdCounter++;
    const area = {
      id: areaId,
      name: `${parentBranch.name}-服务区-${i}`,
      parentId: parentBranch.id,
      parentName: parentBranch.name,
      orgType: "SERVICE_AREA",
      legalEntity: legalEntity,
      children: [],
    };
    parentBranch.children.push(area);
    createUser(`经理-${parentBranch.name.charAt(2)}区${i}`, area.id, roles.find(r => r.id === 4));

    for (let j = 1; j <= stationPerArea; j++) {
      const stationId = orgIdCounter++;
      const station = {
        id: stationId,
        name: `加油站-${String.fromCharCode(64 + j)}`, // A, B
        parentId: area.id,
        parentName: area.name,
        orgType: "GAS_STATION",
        legalEntity: legalEntity,
        children: [],
      };
      area.children.push(station);
      createUser(`站长-${parentBranch.name.charAt(2)}区${i}站${j}`, stationId, roles.find(r => r.id === 5));
    }
  }
}

// 假设前2个分公司管理A公司业务，后5个分公司管理G公司业务
// A公司: 8个服务区，16个加油站 (分配给2个分公司，每个分公司4个服务区)
createServiceAreasAndStations(branches[0], 4, 2, aCompany);
createServiceAreasAndStations(branches[1], 4, 2, aCompany);

// G公司: 70个服务区, 140个加油站 (分配给5个分公司，每个分公司14个服务区)
for (let i = 2; i < 7; i++) {
  createServiceAreasAndStations(branches[i], 14, 2, gCompany);
}

// 最终导出的数据
export const orgTreeData = [root]; // 树形数据
export const userData = allUsers; // 扁平的用户列表